BEGIN;

ALTER TABLE Driver
  ALTER COLUMN driverid ADD GENERATED BY DEFAULT AS IDENTITY;

SELECT setval(
  pg_get_serial_sequence('Driver', 'driverid'),
  (SELECT MAX(driverid) FROM Driver)
);

COMMIT;

BEGIN;

ALTER TABLE Constructors
  ALTER COLUMN constructorid ADD GENERATED BY DEFAULT AS IDENTITY;

SELECT setval(
  pg_get_serial_sequence('Constructors', 'constructorid'),
  (SELECT MAX(constructorid) FROM Constructors)
);

COMMIT;

CREATE TABLE IF NOT EXISTS USERS (
    userid SERIAL PRIMARY KEY,
    login VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    tipo VARCHAR(20) CHECK (tipo IN ('Administrador', 'Escuderia', 'Piloto')) NOT NULL,
    idoriginal INTEGER DEFAULT NULL
);

-- Transação para inserir usuários iniciais
BEGIN;

INSERT INTO USERS (login, password, tipo)
VALUES 
('admin', 'admin', 'Administrador');

INSERT INTO USERS (login, password, tipo, idoriginal)
SELECT ConstructorRef || '_c', ConstructorRef, 'Escuderia', ConstructorId
FROM Constructors;

INSERT INTO USERS (login, password, tipo, idoriginal)
SELECT DriverRef || '_d', DriverRef, 'Piloto', DriverId
FROM Driver;

COMMIT;

CREATE TABLE IF NOT EXISTS USERS_LOG (
    userid SERIAL,
    data DATE NOT NULL,
    hora TIME NOT NULL,
    PRIMARY KEY (userid, data, hora),
    FOREIGN KEY (userid) REFERENCES USERS(userid) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE OR REPLACE FUNCTION AutenticaUsuario(s_login VARCHAR(50), s_password VARCHAR(255))
    RETURNS TABLE(
        userid INTEGER,
        login VARCHAR(50),
        tipo VARCHAR(20),
        idoriginal INTEGER,
        success BOOLEAN,
        message TEXT
    ) 
    LANGUAGE plpgsql
AS $$
DECLARE
    r_userid INTEGER;
    r_login VARCHAR(50);
    r_tipo VARCHAR(20);
    r_idoriginal INTEGER;
    r_stored_password VARCHAR(255);
    r_login_time TIMESTAMP;
BEGIN
    r_login_time := CURRENT_TIMESTAMP;
    
    -- Tenta localizar o usuário
    SELECT u.userid, u.login, u.tipo, u.idoriginal, u.password
    INTO r_userid, r_login, r_tipo, r_idoriginal, r_stored_password
    FROM USERS u
    WHERE u.login = s_login;
    
    -- Verifica se usuário existe
    IF r_userid IS NULL THEN
        RETURN QUERY SELECT 
            NULL::INTEGER, 
            NULL::VARCHAR(50), 
            NULL::VARCHAR(20), 
            NULL::INTEGER,
            FALSE, 
            'Usuário não encontrado'::TEXT;
        RETURN;
    END IF;
    
    -- Verifica a senha
    IF r_stored_password != s_password THEN
        RETURN QUERY SELECT 
            NULL::INTEGER, 
            NULL::VARCHAR(50), 
            NULL::VARCHAR(20), 
            NULL::INTEGER,
            FALSE, 
            'Senha incorreta'::TEXT;
        RETURN;
    END IF;
    
    -- Login bem-sucedido - registra no log de auditoria
    INSERT INTO Users_Log (userid, data, hora)
    VALUES (r_userid, r_login_time::DATE, r_login_time::TIME);
    
    -- Retorna dados do usuário autenticado
    RETURN QUERY SELECT 
        r_userid, 
        r_login, 
        r_tipo, 
        r_idoriginal,
        TRUE, 
        'Login realizado com sucesso'::TEXT;
        
EXCEPTION
    WHEN OTHERS THEN
        -- Em caso de erro, a transação é automaticamente desfeita
        RETURN QUERY SELECT 
            NULL::INTEGER, 
            NULL::VARCHAR(50), 
            NULL::VARCHAR(20), 
            NULL::INTEGER,
            FALSE, 
            ('Erro interno: ' || SQLERRM)::TEXT;
END;
$$;

CREATE OR REPLACE FUNCTION AtualizaUsuarioPiloto()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        -- Atualiza o usuário existente para o piloto
        UPDATE USERS 
        SET login = NEW.DriverRef || '_d', 
            password = NEW.DriverRef, 
            tipo = 'Piloto',
            idoriginal = NEW.DriverId
        WHERE login = OLD.DriverRef || '_d';
    ELSIF TG_OP = 'DELETE' THEN
        -- Remove o usuário do piloto
        DELETE FROM USERS 
        WHERE login = OLD.DriverRef || '_d';
    ELSE 
        INSERT INTO USERS (login, password, tipo, idoriginal)
        VALUES (NEW.DriverRef || '_d', NEW.DriverRef, 'Piloto', NEW.DriverId);
    END IF;    
    
    RETURN NULL;
END;
$$;

CREATE TRIGGER Tr_UsersDrivers
AFTER INSERT OR UPDATE OR DELETE ON Driver
FOR EACH ROW
EXECUTE FUNCTION AtualizaUsuarioPiloto();

CREATE OR REPLACE FUNCTION AtualizaUsuarioEscuderia()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        -- Atualiza o usuário existente para a escuderia
        UPDATE USERS 
        SET login = NEW.ConstructorRef || '_c', 
            password = NEW.ConstructorRef, 
            tipo = 'Escuderia',
            idoriginal = NEW.ConstructorId
        WHERE login = OLD.ConstructorRef || '_c';
    ELSIF TG_OP = 'DELETE' THEN
        -- Remove o usuário da escuderia
        DELETE FROM USERS 
        WHERE login = OLD.ConstructorRef || '_c';
    ELSE 
        INSERT INTO USERS (login, password, tipo, idoriginal)
        VALUES (NEW.ConstructorRef || '_c', NEW.ConstructorRef, 'Escuderia', NEW.ConstructorId);
    END IF;    
    
    RETURN NULL;
END;
$$;

CREATE TRIGGER Tr_UsersConstructors
AFTER INSERT OR UPDATE OR DELETE ON Constructors
FOR EACH ROW
EXECUTE FUNCTION AtualizaUsuarioEscuderia();

CREATE OR REPLACE FUNCTION ObterInfoUsuario(s_login VARCHAR(50))
    RETURNS TABLE(
        Login VARCHAR(50),
        Tipo VARCHAR(20),
        NomePiloto TEXT,
        PilotoEscuderiaAtual TEXT,
        NomeEscuderia TEXT,
        QuantidadePilotos INTEGER
    )
    LANGUAGE plpgsql
AS $$
DECLARE
    v_user_tipo users.tipo%TYPE;
    v_idoriginal users.idoriginal%TYPE;
BEGIN
    SELECT u.tipo, u.idoriginal INTO v_user_tipo, v_idoriginal
    FROM users u
    WHERE u.login = s_login;

    IF NOT FOUND THEN
        RETURN;
    END IF;

    Login := s_login;
    Tipo := v_user_tipo;

    IF v_user_tipo = 'Piloto' THEN
        SELECT
            d.Forename || ' ' || d.Surname,
            c.Name
        INTO
            NomePiloto,
            PilotoEscuderiaAtual
        FROM driver d
        LEFT JOIN results r ON d.driverid = r.driverid -- Informações do construtor na tabela results, Left join caso piloto não tenha corrido
        LEFT JOIN races r2 ON r2.raceid = r.raceid -- Informações do ano da corrida na tabela races
        LEFT JOIN constructors c ON r.constructorid = c.constructorid -- Informações do nome da escuderia na tabela constructors
        WHERE d.driverid = v_idoriginal
        ORDER BY r2.date DESC 
        LIMIT 1;
    ELSIF v_user_tipo = 'Escuderia' THEN
		SELECT c.name, COUNT(DISTINCT r.driverid)
		INTO NomeEscuderia, QuantidadePilotos
		FROM constructors c
		LEFT JOIN results r on r.constructorid = c.constructorid -- Left join caso escuderia não tenha disputado corridas
		WHERE c.constructorid = v_idoriginal
		GROUP BY c.name;
    END IF;

    RETURN NEXT;

END;
$$;